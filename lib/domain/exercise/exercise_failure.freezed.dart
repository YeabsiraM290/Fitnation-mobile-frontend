// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'exercise_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ExerciseFailureTearOff {
  const _$ExerciseFailureTearOff();

// ignore: unused_element
  ServerError serverError() {
    return const ServerError();
  }

// ignore: unused_element
  ExerciseNotSelected exerciseNotSelected() {
    return const ExerciseNotSelected();
  }

// ignore: unused_element
  ExerciseExists exerciseExists() {
    return const ExerciseExists();
  }

// ignore: unused_element
  ExerciseNotFound exerciseNotFound() {
    return const ExerciseNotFound();
  }
}

/// @nodoc
// ignore: unused_element
const $ExerciseFailure = _$ExerciseFailureTearOff();

/// @nodoc
mixin _$ExerciseFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult serverError(),
    @required TResult exerciseNotSelected(),
    @required TResult exerciseExists(),
    @required TResult exerciseNotFound(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult serverError(),
    TResult exerciseNotSelected(),
    TResult exerciseExists(),
    TResult exerciseNotFound(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult serverError(ServerError value),
    @required TResult exerciseNotSelected(ExerciseNotSelected value),
    @required TResult exerciseExists(ExerciseExists value),
    @required TResult exerciseNotFound(ExerciseNotFound value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult serverError(ServerError value),
    TResult exerciseNotSelected(ExerciseNotSelected value),
    TResult exerciseExists(ExerciseExists value),
    TResult exerciseNotFound(ExerciseNotFound value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $ExerciseFailureCopyWith<$Res> {
  factory $ExerciseFailureCopyWith(
          ExerciseFailure value, $Res Function(ExerciseFailure) then) =
      _$ExerciseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$ExerciseFailureCopyWithImpl<$Res>
    implements $ExerciseFailureCopyWith<$Res> {
  _$ExerciseFailureCopyWithImpl(this._value, this._then);

  final ExerciseFailure _value;
  // ignore: unused_field
  final $Res Function(ExerciseFailure) _then;
}

/// @nodoc
abstract class $ServerErrorCopyWith<$Res> {
  factory $ServerErrorCopyWith(
          ServerError value, $Res Function(ServerError) then) =
      _$ServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$ServerErrorCopyWithImpl<$Res>
    extends _$ExerciseFailureCopyWithImpl<$Res>
    implements $ServerErrorCopyWith<$Res> {
  _$ServerErrorCopyWithImpl(
      ServerError _value, $Res Function(ServerError) _then)
      : super(_value, (v) => _then(v as ServerError));

  @override
  ServerError get _value => super._value as ServerError;
}

/// @nodoc
class _$ServerError with DiagnosticableTreeMixin implements ServerError {
  const _$ServerError();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ExerciseFailure.serverError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ExerciseFailure.serverError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult serverError(),
    @required TResult exerciseNotSelected(),
    @required TResult exerciseExists(),
    @required TResult exerciseNotFound(),
  }) {
    assert(serverError != null);
    assert(exerciseNotSelected != null);
    assert(exerciseExists != null);
    assert(exerciseNotFound != null);
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult serverError(),
    TResult exerciseNotSelected(),
    TResult exerciseExists(),
    TResult exerciseNotFound(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult serverError(ServerError value),
    @required TResult exerciseNotSelected(ExerciseNotSelected value),
    @required TResult exerciseExists(ExerciseExists value),
    @required TResult exerciseNotFound(ExerciseNotFound value),
  }) {
    assert(serverError != null);
    assert(exerciseNotSelected != null);
    assert(exerciseExists != null);
    assert(exerciseNotFound != null);
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult serverError(ServerError value),
    TResult exerciseNotSelected(ExerciseNotSelected value),
    TResult exerciseExists(ExerciseExists value),
    TResult exerciseNotFound(ExerciseNotFound value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError implements ExerciseFailure {
  const factory ServerError() = _$ServerError;
}

/// @nodoc
abstract class $ExerciseNotSelectedCopyWith<$Res> {
  factory $ExerciseNotSelectedCopyWith(
          ExerciseNotSelected value, $Res Function(ExerciseNotSelected) then) =
      _$ExerciseNotSelectedCopyWithImpl<$Res>;
}

/// @nodoc
class _$ExerciseNotSelectedCopyWithImpl<$Res>
    extends _$ExerciseFailureCopyWithImpl<$Res>
    implements $ExerciseNotSelectedCopyWith<$Res> {
  _$ExerciseNotSelectedCopyWithImpl(
      ExerciseNotSelected _value, $Res Function(ExerciseNotSelected) _then)
      : super(_value, (v) => _then(v as ExerciseNotSelected));

  @override
  ExerciseNotSelected get _value => super._value as ExerciseNotSelected;
}

/// @nodoc
class _$ExerciseNotSelected
    with DiagnosticableTreeMixin
    implements ExerciseNotSelected {
  const _$ExerciseNotSelected();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ExerciseFailure.exerciseNotSelected()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ExerciseFailure.exerciseNotSelected'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ExerciseNotSelected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult serverError(),
    @required TResult exerciseNotSelected(),
    @required TResult exerciseExists(),
    @required TResult exerciseNotFound(),
  }) {
    assert(serverError != null);
    assert(exerciseNotSelected != null);
    assert(exerciseExists != null);
    assert(exerciseNotFound != null);
    return exerciseNotSelected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult serverError(),
    TResult exerciseNotSelected(),
    TResult exerciseExists(),
    TResult exerciseNotFound(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exerciseNotSelected != null) {
      return exerciseNotSelected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult serverError(ServerError value),
    @required TResult exerciseNotSelected(ExerciseNotSelected value),
    @required TResult exerciseExists(ExerciseExists value),
    @required TResult exerciseNotFound(ExerciseNotFound value),
  }) {
    assert(serverError != null);
    assert(exerciseNotSelected != null);
    assert(exerciseExists != null);
    assert(exerciseNotFound != null);
    return exerciseNotSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult serverError(ServerError value),
    TResult exerciseNotSelected(ExerciseNotSelected value),
    TResult exerciseExists(ExerciseExists value),
    TResult exerciseNotFound(ExerciseNotFound value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exerciseNotSelected != null) {
      return exerciseNotSelected(this);
    }
    return orElse();
  }
}

abstract class ExerciseNotSelected implements ExerciseFailure {
  const factory ExerciseNotSelected() = _$ExerciseNotSelected;
}

/// @nodoc
abstract class $ExerciseExistsCopyWith<$Res> {
  factory $ExerciseExistsCopyWith(
          ExerciseExists value, $Res Function(ExerciseExists) then) =
      _$ExerciseExistsCopyWithImpl<$Res>;
}

/// @nodoc
class _$ExerciseExistsCopyWithImpl<$Res>
    extends _$ExerciseFailureCopyWithImpl<$Res>
    implements $ExerciseExistsCopyWith<$Res> {
  _$ExerciseExistsCopyWithImpl(
      ExerciseExists _value, $Res Function(ExerciseExists) _then)
      : super(_value, (v) => _then(v as ExerciseExists));

  @override
  ExerciseExists get _value => super._value as ExerciseExists;
}

/// @nodoc
class _$ExerciseExists with DiagnosticableTreeMixin implements ExerciseExists {
  const _$ExerciseExists();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ExerciseFailure.exerciseExists()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ExerciseFailure.exerciseExists'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ExerciseExists);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult serverError(),
    @required TResult exerciseNotSelected(),
    @required TResult exerciseExists(),
    @required TResult exerciseNotFound(),
  }) {
    assert(serverError != null);
    assert(exerciseNotSelected != null);
    assert(exerciseExists != null);
    assert(exerciseNotFound != null);
    return exerciseExists();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult serverError(),
    TResult exerciseNotSelected(),
    TResult exerciseExists(),
    TResult exerciseNotFound(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exerciseExists != null) {
      return exerciseExists();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult serverError(ServerError value),
    @required TResult exerciseNotSelected(ExerciseNotSelected value),
    @required TResult exerciseExists(ExerciseExists value),
    @required TResult exerciseNotFound(ExerciseNotFound value),
  }) {
    assert(serverError != null);
    assert(exerciseNotSelected != null);
    assert(exerciseExists != null);
    assert(exerciseNotFound != null);
    return exerciseExists(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult serverError(ServerError value),
    TResult exerciseNotSelected(ExerciseNotSelected value),
    TResult exerciseExists(ExerciseExists value),
    TResult exerciseNotFound(ExerciseNotFound value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exerciseExists != null) {
      return exerciseExists(this);
    }
    return orElse();
  }
}

abstract class ExerciseExists implements ExerciseFailure {
  const factory ExerciseExists() = _$ExerciseExists;
}

/// @nodoc
abstract class $ExerciseNotFoundCopyWith<$Res> {
  factory $ExerciseNotFoundCopyWith(
          ExerciseNotFound value, $Res Function(ExerciseNotFound) then) =
      _$ExerciseNotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class _$ExerciseNotFoundCopyWithImpl<$Res>
    extends _$ExerciseFailureCopyWithImpl<$Res>
    implements $ExerciseNotFoundCopyWith<$Res> {
  _$ExerciseNotFoundCopyWithImpl(
      ExerciseNotFound _value, $Res Function(ExerciseNotFound) _then)
      : super(_value, (v) => _then(v as ExerciseNotFound));

  @override
  ExerciseNotFound get _value => super._value as ExerciseNotFound;
}

/// @nodoc
class _$ExerciseNotFound
    with DiagnosticableTreeMixin
    implements ExerciseNotFound {
  const _$ExerciseNotFound();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ExerciseFailure.exerciseNotFound()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ExerciseFailure.exerciseNotFound'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ExerciseNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult serverError(),
    @required TResult exerciseNotSelected(),
    @required TResult exerciseExists(),
    @required TResult exerciseNotFound(),
  }) {
    assert(serverError != null);
    assert(exerciseNotSelected != null);
    assert(exerciseExists != null);
    assert(exerciseNotFound != null);
    return exerciseNotFound();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult serverError(),
    TResult exerciseNotSelected(),
    TResult exerciseExists(),
    TResult exerciseNotFound(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exerciseNotFound != null) {
      return exerciseNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult serverError(ServerError value),
    @required TResult exerciseNotSelected(ExerciseNotSelected value),
    @required TResult exerciseExists(ExerciseExists value),
    @required TResult exerciseNotFound(ExerciseNotFound value),
  }) {
    assert(serverError != null);
    assert(exerciseNotSelected != null);
    assert(exerciseExists != null);
    assert(exerciseNotFound != null);
    return exerciseNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult serverError(ServerError value),
    TResult exerciseNotSelected(ExerciseNotSelected value),
    TResult exerciseExists(ExerciseExists value),
    TResult exerciseNotFound(ExerciseNotFound value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exerciseNotFound != null) {
      return exerciseNotFound(this);
    }
    return orElse();
  }
}

abstract class ExerciseNotFound implements ExerciseFailure {
  const factory ExerciseNotFound() = _$ExerciseNotFound;
}
