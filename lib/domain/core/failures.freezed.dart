// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

// ignore: unused_element
  InvalidEmail<T> invalidEmail<T>({@required T failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ShortPassword<T> shortPassword<T>({@required T failedValue}) {
    return ShortPassword<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ShortName<T> shortName<T>({@required T failedValue}) {
    return ShortName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ListEmpty<T> listEmpty<T>({@required T failedValue}) {
    return ListEmpty<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ShortUrl<T> shortUrl<T>({@required T failedValue}) {
    return ShortUrl<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ShortUsername<T> shortUsername<T>({@required T failedValue}) {
    return ShortUsername<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidAge<T> invalidAge<T>({@required T failedValue}) {
    return InvalidAge<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidRepetation<T> invalidRepetation<T>({@required T failedValue}) {
    return InvalidRepetation<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidHeight<T> invalidHeight<T>({@required T failedValue}) {
    return InvalidHeight<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSex<T> invalidSex<T>({@required T failedValue}) {
    return InvalidSex<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidWeight<T> invalidWeight<T>({@required T failedValue}) {
    return InvalidWeight<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  T get failedValue;

  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  });

  @JsonKey(ignore: true)
  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({@required T failedValue}) = _$InvalidEmail<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith;
}

/// @nodoc
abstract class $ShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortPasswordCopyWith(
          ShortPassword<T> value, $Res Function(ShortPassword<T>) then) =
      _$ShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortPasswordCopyWith<T, $Res> {
  _$ShortPasswordCopyWithImpl(
      ShortPassword<T> _value, $Res Function(ShortPassword<T>) _then)
      : super(_value, (v) => _then(v as ShortPassword<T>));

  @override
  ShortPassword<T> get _value => super._value as ShortPassword<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortPassword<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$ShortPassword<T> implements ShortPassword<T> {
  const _$ShortPassword({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      _$ShortPasswordCopyWithImpl<T, ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return shortPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortPassword != null) {
      return shortPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  const factory ShortPassword({@required T failedValue}) = _$ShortPassword<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith;
}

/// @nodoc
abstract class $ShortNameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortNameCopyWith(
          ShortName<T> value, $Res Function(ShortName<T>) then) =
      _$ShortNameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortNameCopyWith<T, $Res> {
  _$ShortNameCopyWithImpl(
      ShortName<T> _value, $Res Function(ShortName<T>) _then)
      : super(_value, (v) => _then(v as ShortName<T>));

  @override
  ShortName<T> get _value => super._value as ShortName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$ShortName<T> implements ShortName<T> {
  const _$ShortName({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $ShortNameCopyWith<T, ShortName<T>> get copyWith =>
      _$ShortNameCopyWithImpl<T, ShortName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return shortName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortName != null) {
      return shortName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return shortName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortName != null) {
      return shortName(this);
    }
    return orElse();
  }
}

abstract class ShortName<T> implements ValueFailure<T> {
  const factory ShortName({@required T failedValue}) = _$ShortName<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $ShortNameCopyWith<T, ShortName<T>> get copyWith;
}

/// @nodoc
abstract class $ListEmptyCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ListEmptyCopyWith(
          ListEmpty<T> value, $Res Function(ListEmpty<T>) then) =
      _$ListEmptyCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ListEmptyCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ListEmptyCopyWith<T, $Res> {
  _$ListEmptyCopyWithImpl(
      ListEmpty<T> _value, $Res Function(ListEmpty<T>) _then)
      : super(_value, (v) => _then(v as ListEmpty<T>));

  @override
  ListEmpty<T> get _value => super._value as ListEmpty<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ListEmpty<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$ListEmpty<T> implements ListEmpty<T> {
  const _$ListEmpty({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.listEmpty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ListEmpty<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $ListEmptyCopyWith<T, ListEmpty<T>> get copyWith =>
      _$ListEmptyCopyWithImpl<T, ListEmpty<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return listEmpty(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (listEmpty != null) {
      return listEmpty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return listEmpty(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (listEmpty != null) {
      return listEmpty(this);
    }
    return orElse();
  }
}

abstract class ListEmpty<T> implements ValueFailure<T> {
  const factory ListEmpty({@required T failedValue}) = _$ListEmpty<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $ListEmptyCopyWith<T, ListEmpty<T>> get copyWith;
}

/// @nodoc
abstract class $ShortUrlCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortUrlCopyWith(
          ShortUrl<T> value, $Res Function(ShortUrl<T>) then) =
      _$ShortUrlCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortUrlCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortUrlCopyWith<T, $Res> {
  _$ShortUrlCopyWithImpl(ShortUrl<T> _value, $Res Function(ShortUrl<T>) _then)
      : super(_value, (v) => _then(v as ShortUrl<T>));

  @override
  ShortUrl<T> get _value => super._value as ShortUrl<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortUrl<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$ShortUrl<T> implements ShortUrl<T> {
  const _$ShortUrl({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortUrl(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortUrl<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $ShortUrlCopyWith<T, ShortUrl<T>> get copyWith =>
      _$ShortUrlCopyWithImpl<T, ShortUrl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return shortUrl(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortUrl != null) {
      return shortUrl(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return shortUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortUrl != null) {
      return shortUrl(this);
    }
    return orElse();
  }
}

abstract class ShortUrl<T> implements ValueFailure<T> {
  const factory ShortUrl({@required T failedValue}) = _$ShortUrl<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $ShortUrlCopyWith<T, ShortUrl<T>> get copyWith;
}

/// @nodoc
abstract class $ShortUsernameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortUsernameCopyWith(
          ShortUsername<T> value, $Res Function(ShortUsername<T>) then) =
      _$ShortUsernameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortUsernameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortUsernameCopyWith<T, $Res> {
  _$ShortUsernameCopyWithImpl(
      ShortUsername<T> _value, $Res Function(ShortUsername<T>) _then)
      : super(_value, (v) => _then(v as ShortUsername<T>));

  @override
  ShortUsername<T> get _value => super._value as ShortUsername<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortUsername<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$ShortUsername<T> implements ShortUsername<T> {
  const _$ShortUsername({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortUsername(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortUsername<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $ShortUsernameCopyWith<T, ShortUsername<T>> get copyWith =>
      _$ShortUsernameCopyWithImpl<T, ShortUsername<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return shortUsername(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortUsername != null) {
      return shortUsername(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return shortUsername(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortUsername != null) {
      return shortUsername(this);
    }
    return orElse();
  }
}

abstract class ShortUsername<T> implements ValueFailure<T> {
  const factory ShortUsername({@required T failedValue}) = _$ShortUsername<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $ShortUsernameCopyWith<T, ShortUsername<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidAgeCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidAgeCopyWith(
          InvalidAge<T> value, $Res Function(InvalidAge<T>) then) =
      _$InvalidAgeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidAgeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidAgeCopyWith<T, $Res> {
  _$InvalidAgeCopyWithImpl(
      InvalidAge<T> _value, $Res Function(InvalidAge<T>) _then)
      : super(_value, (v) => _then(v as InvalidAge<T>));

  @override
  InvalidAge<T> get _value => super._value as InvalidAge<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidAge<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidAge<T> implements InvalidAge<T> {
  const _$InvalidAge({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidAge(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidAge<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidAgeCopyWith<T, InvalidAge<T>> get copyWith =>
      _$InvalidAgeCopyWithImpl<T, InvalidAge<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidAge(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAge != null) {
      return invalidAge(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidAge(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAge != null) {
      return invalidAge(this);
    }
    return orElse();
  }
}

abstract class InvalidAge<T> implements ValueFailure<T> {
  const factory InvalidAge({@required T failedValue}) = _$InvalidAge<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidAgeCopyWith<T, InvalidAge<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidRepetationCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidRepetationCopyWith(InvalidRepetation<T> value,
          $Res Function(InvalidRepetation<T>) then) =
      _$InvalidRepetationCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidRepetationCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidRepetationCopyWith<T, $Res> {
  _$InvalidRepetationCopyWithImpl(
      InvalidRepetation<T> _value, $Res Function(InvalidRepetation<T>) _then)
      : super(_value, (v) => _then(v as InvalidRepetation<T>));

  @override
  InvalidRepetation<T> get _value => super._value as InvalidRepetation<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidRepetation<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidRepetation<T> implements InvalidRepetation<T> {
  const _$InvalidRepetation({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidRepetation(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidRepetation<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidRepetationCopyWith<T, InvalidRepetation<T>> get copyWith =>
      _$InvalidRepetationCopyWithImpl<T, InvalidRepetation<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidRepetation(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidRepetation != null) {
      return invalidRepetation(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidRepetation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidRepetation != null) {
      return invalidRepetation(this);
    }
    return orElse();
  }
}

abstract class InvalidRepetation<T> implements ValueFailure<T> {
  const factory InvalidRepetation({@required T failedValue}) =
      _$InvalidRepetation<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidRepetationCopyWith<T, InvalidRepetation<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidHeightCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidHeightCopyWith(
          InvalidHeight<T> value, $Res Function(InvalidHeight<T>) then) =
      _$InvalidHeightCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidHeightCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidHeightCopyWith<T, $Res> {
  _$InvalidHeightCopyWithImpl(
      InvalidHeight<T> _value, $Res Function(InvalidHeight<T>) _then)
      : super(_value, (v) => _then(v as InvalidHeight<T>));

  @override
  InvalidHeight<T> get _value => super._value as InvalidHeight<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidHeight<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidHeight<T> implements InvalidHeight<T> {
  const _$InvalidHeight({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidHeight(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidHeight<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidHeightCopyWith<T, InvalidHeight<T>> get copyWith =>
      _$InvalidHeightCopyWithImpl<T, InvalidHeight<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidHeight(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidHeight != null) {
      return invalidHeight(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidHeight(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidHeight != null) {
      return invalidHeight(this);
    }
    return orElse();
  }
}

abstract class InvalidHeight<T> implements ValueFailure<T> {
  const factory InvalidHeight({@required T failedValue}) = _$InvalidHeight<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidHeightCopyWith<T, InvalidHeight<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSexCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidSexCopyWith(
          InvalidSex<T> value, $Res Function(InvalidSex<T>) then) =
      _$InvalidSexCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSexCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidSexCopyWith<T, $Res> {
  _$InvalidSexCopyWithImpl(
      InvalidSex<T> _value, $Res Function(InvalidSex<T>) _then)
      : super(_value, (v) => _then(v as InvalidSex<T>));

  @override
  InvalidSex<T> get _value => super._value as InvalidSex<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSex<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSex<T> implements InvalidSex<T> {
  const _$InvalidSex({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidSex(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSex<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidSexCopyWith<T, InvalidSex<T>> get copyWith =>
      _$InvalidSexCopyWithImpl<T, InvalidSex<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidSex(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidSex != null) {
      return invalidSex(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidSex(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidSex != null) {
      return invalidSex(this);
    }
    return orElse();
  }
}

abstract class InvalidSex<T> implements ValueFailure<T> {
  const factory InvalidSex({@required T failedValue}) = _$InvalidSex<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidSexCopyWith<T, InvalidSex<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidWeightCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidWeightCopyWith(
          InvalidWeight<T> value, $Res Function(InvalidWeight<T>) then) =
      _$InvalidWeightCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidWeightCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidWeightCopyWith<T, $Res> {
  _$InvalidWeightCopyWithImpl(
      InvalidWeight<T> _value, $Res Function(InvalidWeight<T>) _then)
      : super(_value, (v) => _then(v as InvalidWeight<T>));

  @override
  InvalidWeight<T> get _value => super._value as InvalidWeight<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidWeight<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidWeight<T> implements InvalidWeight<T> {
  const _$InvalidWeight({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidWeight(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidWeight<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidWeightCopyWith<T, InvalidWeight<T>> get copyWith =>
      _$InvalidWeightCopyWithImpl<T, InvalidWeight<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult shortName(T failedValue),
    @required TResult listEmpty(T failedValue),
    @required TResult shortUrl(T failedValue),
    @required TResult shortUsername(T failedValue),
    @required TResult invalidAge(T failedValue),
    @required TResult invalidRepetation(T failedValue),
    @required TResult invalidHeight(T failedValue),
    @required TResult invalidSex(T failedValue),
    @required TResult invalidWeight(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidWeight(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult shortName(T failedValue),
    TResult listEmpty(T failedValue),
    TResult shortUrl(T failedValue),
    TResult shortUsername(T failedValue),
    TResult invalidAge(T failedValue),
    TResult invalidRepetation(T failedValue),
    TResult invalidHeight(T failedValue),
    TResult invalidSex(T failedValue),
    TResult invalidWeight(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidWeight != null) {
      return invalidWeight(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult shortName(ShortName<T> value),
    @required TResult listEmpty(ListEmpty<T> value),
    @required TResult shortUrl(ShortUrl<T> value),
    @required TResult shortUsername(ShortUsername<T> value),
    @required TResult invalidAge(InvalidAge<T> value),
    @required TResult invalidRepetation(InvalidRepetation<T> value),
    @required TResult invalidHeight(InvalidHeight<T> value),
    @required TResult invalidSex(InvalidSex<T> value),
    @required TResult invalidWeight(InvalidWeight<T> value),
  }) {
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(shortName != null);
    assert(listEmpty != null);
    assert(shortUrl != null);
    assert(shortUsername != null);
    assert(invalidAge != null);
    assert(invalidRepetation != null);
    assert(invalidHeight != null);
    assert(invalidSex != null);
    assert(invalidWeight != null);
    return invalidWeight(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult shortName(ShortName<T> value),
    TResult listEmpty(ListEmpty<T> value),
    TResult shortUrl(ShortUrl<T> value),
    TResult shortUsername(ShortUsername<T> value),
    TResult invalidAge(InvalidAge<T> value),
    TResult invalidRepetation(InvalidRepetation<T> value),
    TResult invalidHeight(InvalidHeight<T> value),
    TResult invalidSex(InvalidSex<T> value),
    TResult invalidWeight(InvalidWeight<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidWeight != null) {
      return invalidWeight(this);
    }
    return orElse();
  }
}

abstract class InvalidWeight<T> implements ValueFailure<T> {
  const factory InvalidWeight({@required T failedValue}) = _$InvalidWeight<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidWeightCopyWith<T, InvalidWeight<T>> get copyWith;
}
